## Redis——数据结构与对象


### 简单动态字符串（SDS）
Redis自己创建了一种名为简单字符串的抽象类型(simple dynamic string)，作为Redis默认的字符串表示。
#### SDS结构
```c
struct sdshdr {

    // 记录buf数据中已使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;

    // 记录buf数据宗伟使用的字节数量
    int free;

    // 字节数组，用来保存字符串
    char buf[];
}
```
#### SDS与C字符串的区别
- 获取C字符串长度需要遍历整个字符串，复杂度为O(N)，SDS只需要读取len属性，复杂度O(1)
- 杜绝缓冲区溢出，C字符串使用`strcat`拼接字符串时，如果没有分配足够的内存，容易造成缓冲区溢出，SDS在`sdscat`函数执行时会先检查是否有足够空间。
- 减少修改字符串时带来的内存重新分配次数，当C字符串进行缩短操作时，会立刻释放多余内存，后续进行拼接时又需要重新分配扩展，SDS在缩短后不会立刻释放内存，采用**空间预分配**和**惰性空间释放**的策略来避免内存空间频繁改动。
- 保障二进制安全，C字符串必须符合某种编码，并且除了字符串末尾，不能含有空字符，否则会被误认为是字符串的结尾，使得C字符串只能保存文本，而不能保存图片、音视频等二进制数据。SDS的buf数组可以保存二进制数据，是二进制安全的。
- SDS兼容部分C字符串函数，SDS遵循C字符串末尾是`\0`空字符的惯例，因此可以使用一部分`<string.h>`库定义的函数。

### 链表
#### 链表结构
链表节点：
```c
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
```

链表：
```c
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾结点
    listNode *tail;

    // 链表所包含的节点数量
    unsigned long len;

    // 节点值复制函数
    void *(*dup) (void *ptr);

    // 节点值释放函数
    void *(*free) (void *ptr);

    // 节点值对比函数
    void *(*match) (void *ptr, void *key);

    
} list
```

#### 链表特性

- 双端
- 无环，表头节点的prev指针和表尾结点的next指针都指向`null`，对链表的访问以`null`为终点
- 带头指针和尾指针
- 带链表长度计数器
- 多态，节点使用`void*`指针来保存节点值，可以用于保存各种不同类型的值。

### 字典
字典的实现使用哈希表作为底层结构，一个哈希表里可以有多个哈希表节点，每个哈希表节点保存一个字典中的键值对。

##### 哈希表的定义
```c
typedef struct dictht {

    // 哈希表数组
    dictEntry **table;

    // 哈希表大小
    unsigned long size;

    // 哈希表大小掩码，用于计算索引，总是等于size-1
    unsigned long sizemask;

    // 哈希表已有节点的数量
    unsigned long used;

} dictht
```
##### 哈希表节点定义
```c
typedef struct dictEntry {

    // 键
    void *key;

    // 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v

    // 指向下一个哈希表节点，形成链表
    // 用于处理哈希冲突
    struct dictEntry *next;

} dictEntry
```
##### 字典的定义

```c
typedef struct dict {

    // 类型特定函数
    dictType *type;

    // 私有数据
    void privdata;

    // 哈希表
    dictht ht[2];

    // rehash索引
    int trehashidx;

} dictht
```
 - type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作指定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。
 - private属性保存了需要传给那些类型特定函数的可选参数
 - ht属性是两个项的数组，数组每项都是一个dictht哈希表，ht[0]作为存储数据的容器，ht[1]在哈希表进行rehash时使用。
 - trehashidx记录了rehash的进度，如果当前没有进行rehash，那么它的值是-1

 ##### 总结
 1. 使用MurmurHash2算法作为hash算法，得到hash值使用`hash & dict->ht[0].sizemask`来计算索引值。
 2. 使用拉链法解决哈希冲突。
 3. 扩容或缩容时进行rehash，容量总是2的次幂，并且这个过程不是一次性完成，而是渐进式的完成的。
### 跳跃表
跳跃表是一种**有序**的数据结构，本质是一个**双向链表**，通过维持多层的快速访问指针，从而达到快速访问节点的目的。
跳跃表平均支持O(logN)，最坏O(N)的查找复杂度，还可以通过顺序性操作来批量处理节点。

跳跃表
```c
typedef struct zskiplist {

    // 表头节点和表尾结点
    struct zskiplistNode *head, *tail;

    // 表中节点数量
    unsigned long length;

    // 表中层数最大的节点的层数
    int level;

} zskiplist;

```
跳跃表节点
```c
typedef struct zskiplistNode {

    // 后退指针
    struct zskiplistNode *backward

    // 分值
    double *obj;

    // 成员对象
    robj *obj;

    // 层
    struct zskiplistLevel {

        // 前进指针
        struct zskiplistNode *forward;

        // 跨度
        unsigned int span;
        
    } level[];

} zskiplistNode;
```

<img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=633519734,1470329331&fm=26&gp=0.jpg" referrerpolicy="no-referrer">

跳跃表节点按分值大小排序，分值可以相同，但是对象不能相同。
跳跃表节点的层数随机生成，根据幂次定律产生一个1-32的值作为level数组的大小。
> 层数生成使用类似抛硬币的算法，如果抛出正面就继续翻，抛出反面就停止，记录最终抛出正面的次数作为这个元素的层数，将节点加入小于等于这个层数的链表中。


### 整数集合
整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合元素数量不多时，Redis会使用整数集合作为集合键的底层实现。可以保存类型为int16_t, int32_t, int64_t的整数值，并且保证不会有重复元素。
```c
typedef struct intset {

    // 编码方式
    uinit_t encoding；

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];
} intset;
```

虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，类型取决于encoding属性的值：
- 如果encoding属性值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每一项都是int16_t类型的值（-3 2768 ~ 3 2767）
- 如果encoding属性值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每一项都是int32_t类型的值（-21 4748 3648 ~ 21 4748 3647）
- 如果encoding属性值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每一项都是int64_t类型的值（-922 3372 0368 5477 5808 ~ 922 3372 0368 5477 5807）

#### 升级
当将新元素插入整数集合中时，如果超出上限，就需要对整个整数集合进行升级，然后才能将新元素添加到集合中。
升级过程分三步：
1. 根据新元素的类型没扩展整数集合底层数组的空间大小，并为新元素分配空间。
2. 将底层数组现有的所有元素都替换成与新元素相同的类型，并且放到正确的位置上，而且不能改变底层数组原来的顺序。
3. 将新元素添加到底层数组里面。

升级的好处：
- 一个是提高整数集合的灵活性
- 另一个是尽可能的节约内存

> 整数集合**不支持**降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

### 压缩列表

压缩列表是**列表键**和**哈希键**的底层实现之一。当一个列表键只包含**少量列表项**，并且列表项都是**小整数值**或者是**长度较短的字符串**时，那么Redis就会使用压缩列表来做列表键的底层实现。

### 对象

<img src="https://wx4.sinaimg.cn/mw1024/9c96fc9cly1g7hlih7twrj20tg0cp75i.jpg" referrerpolicy="no-referrer">