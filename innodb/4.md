## MySQL技术内幕innodb存储引擎读书笔记（四）

### 一、Innodb事务的实现
事务的隔离性由锁来实现。原子性、一致性、持久性通过数据库的redo log和undo log来完成。
> undo并不是redo的逆过程，两者都可看做是一个恢复操作，redo恢复提交事务修改的页操作，而undo回滚行记录到某个特定版本。

> redo通常是**物理**日志，记录的是页的**物理**修改操作。undo是**逻辑**日志，根据每行记录进行记录。

### 二、redo

#### 1. 基本概念
redo log用来实现事务的持久性，由两部分组成，一部分是内存中的重做日志缓冲，是遗失，另一部分是重做日志文件，是持久的。

##### Force Log at Commit
当事务提交(commit)时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的commit操作完成才算完成。这里的日志指的是重做日志，在Innodb存储引擎当中，由redo log和undo log两部分组成。redo log用来保证事务的持久性，undo log用来帮助回滚事务及实现MVCC功能。

> redo log基本都是顺序写，数据库运行时不需要读取redo log。而undo log时需要随机读写的。

> 参数 **innodb_flush_log_at_trx_commit** 用来控制重做日志刷新到磁盘的策略。默认为1，表示事务提交时必须调用一次fsync操作。还可设为0和2,0表示事务提交时不进行写入重做日志操作，这个操作仅在master thread中完成，而在master thread中每1秒会进行一次重做日志文件的fsync操作。2表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。设为0和2可以提高效率，但是失去了事务ACID的特性。

##### binlog和重做日志的区别
- 首先，重做日志是在引擎层产生，而binlog是在mysql server层产生，而且二进制文件不仅仅针对与Innodb引擎，任何存储引擎对于数据库的修改都会产生binlog。
- 其次，两种日志记录的内容形式不同。MySQL数据库的binlog是一种逻辑日志，其记录的是对应的sql语句。而Innodb的重做日志是物理格式，记录的是每个页的修改。
- 此外，两种日志写入磁盘的时间点不同，binlog只在事务提交完成后进行一次写入。而重做日志在事务进行中不断被写入，表现为日志并不是随事务的提交顺序进行写入的。


#### 2. log block
在Innodb中，重做日志都是以512字节进行存储的。这意味着重做日志文件和重做日志缓存都是以块(block)为单位进行保存的，称之为重做日志块(redo log block)，每块的大小为512字节。

如果一个页产生的日志数量大于512字节，那么需要分割为多个日志块进行存储。

> 由于日志块和磁盘扇区大小一样，都是512字节，因此不需要double write就可以保证原子性。

#### 3. log group
log group 为重做日志组，其中有多个重做日志文件。log group 保存的是之前在 log buffer 中保存的 log block，因此也是根据块来进行物理存储管理，每个块也是512字节。在InnoDB存储引擎运行过程中，log buffer 根据一定的规则将内存中的 log block 刷新到磁盘。这个规则是：
- 事务提交时
- 当 log buffer 中有一半的内存空间已经被使用时
- log checkpoint 时

> redo log file被写满时，会接着写入下一个redo log file，其使用方式为 **round-robin**.

> 每个redo log file的前2k空间部分不保存东西，对于每个log group的第一个redo log file的前2k空间保存了四个512字节大小的块

|名称|大小(字节)|
|---|---|---|
|log file header|512|
|checkpoint1|512|
|空|512|
|checkpoint2|512|

#### 4. LSN
LSN是 Log Sequence Number的缩写，其代表的是日志序列号。在InnoDB中，LSN占用8字节，并且单调递增。LSN表示的含义有：
- 重做日志的总量
- checkpoint的位置
- 页的版本

LSN不仅存在于重做日志中，还存在于每个页中。在每个页的头部，有一个值FIL_PAGE_LSN记录了改业的LSN。在页中，LSN表示改业最后刷新时LSN的大小。因为重做日志记录的是每个页的日志，因此页中的LSN用来判断页是否需要进行回复操作。例如，页P1的LSN是10000，而数据库启动时，InnoDB检测到写入重做日志中的LSN为13000，并且该事务已提交，name数据库需要进行恢复操作，将重做日志应用到P1页中。同样的对于重做日志中LSN晓玉P1页的LSN，不需要进行重做，因为P1页中的LSN表示页已经被刷新到该位置。

用户可以通过**show engine innodb status**查看LSN的情况

```sql
...
---
LOG
---
Log sequence number 1133058903319
Log flushed up to   1133058888909
Pages flushed up to 1133058887714
Last checkpoint at  1133058887714
0 pending log writes, 0 pending chkp writes
61923710 log i/o's done, 4.61 log i/o's/second
...
```
### 三、undo
#### 1.基本概念
在数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样需要回滚是可以利用undo信息将数据回滚到修改之前的亚子。
undo与redo不同，不存放在重做日志文件中，而是存放在数据库内部的一个特殊段中，被称为undo段（undo segment）。undo段位于共享表空间当中。

undo并不是把数据库物理的恢复到以前的样子，undo是一个逻辑过程，例如对于insert就是用一条delete，update会使用一个相反的update，将修改签的行放回去。

除了回滚操作，undo的另一个作用就是**MVCC**，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过读取之前的行版本信息，以此实现非锁定读取。

最后一点，undo也会生成redo信息，也就是undo log的产生会伴随着redo log产生，这是因为undo log也需要持久性的保护。
#### 

