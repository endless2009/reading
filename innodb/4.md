## MySQL技术内幕innodb存储引擎读书笔记（四）

### Innodb事务的实现
事务的隔离性由锁来实现。原子性、一致性、持久性通过数据库的redo log和undo log来完成。
> undo并不是redo的逆过程，两者都可看做是一个恢复操作，redo恢复提交事务修改的页操作，而undo回滚行记录到某个特定版本。

> redo通常是**物理**日志，记录的是页的**物理**修改操作。undo是**逻辑**日志，根据每行记录进行记录。

### redo

#### 1. 基本概念
redo log用来实现事务的持久性，由两部分组成，一部分是内存中的重做日志缓冲，是遗失，另一部分是重做日志文件，是持久的。

##### Force Log at Commit
当事务提交(commit)时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的commit操作完成才算完成。这里的日志指的是重做日志，在Innodb存储引擎当中，由redo log和undo log两部分组成。redo log用来保证事务的持久性，undo log用来帮助回滚事务及实现MVCC功能。

> redo log基本都是顺序写，数据库运行时不需要读取redo log。而undo log时需要随机读写的。

> 参数 **innodb_flush_log_at_trx_commit** 用来控制重做日志刷新到磁盘的策略。默认为1，表示事务提交时必须调用一次fsync操作。还可设为0和2,0表示事务提交时不进行写入重做日志操作，这个操作仅在master thread中完成，而在master thread中每1秒会进行一次重做日志文件的fsync操作。2表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。设为0和2可以提高效率，但是失去了事务ACID的特性。

##### binlog和重做日志的区别
- 首先，重做日志是在引擎层产生，而binlog是在mysql server层产生，而且二进制文件不仅仅针对与Innodb引擎，任何存储引擎对于数据库的修改都会产生binlog。
- 其次，两种日志记录的内容形式不同。MySQL数据库的binlog是一种逻辑日志，其记录的是对应的sql语句。而Innodb的重做日志是物理格式，记录的是每个页的修改。
- 此外，两种日志写入磁盘的时间点不同，binlog只在事务提交完成后进行一次写入。而重做日志在事务进行中不断被写入，表现为日志并不是随事务的提交顺序进行写入的。


#### 2. log block
在Innodb中，重做日志都是以512字节进行存储的。这意味着重做日志文件和重做日志缓存都是以块(block)为单位进行保存的，称之为重做日志块(redo log block)，每块的大小为512字节。

如果一个页产生的日志数量大于512字节，那么需要分割为多个日志块进行存储。

> 由于日志块和磁盘扇区大小一样，都是512字节，因此不需要double write就可以保证原子性。

#### 3. log group
