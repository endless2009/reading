## MySQL技术内幕innodb存储引擎读书笔记（三）
#### latch与lock
latch和lock最大的区别在于，latch是为了保护线程并发过程的资源，lock则是用来保护事务的锁。这里主要讨论后者。
### 1 Innodb的锁


#### 1.1 锁的类型
##### 行级锁
Innodb存储引擎有两种行级锁
- 共享锁(S Lock)：又称读锁
- 排它锁(X Lock)：又称行锁

||X |S |
|--|--|--|
|X |不兼容|不兼容|
|S |不兼容|兼容|

##### 意向锁
- 意向共享锁(IS Lock)：事务想要获得一张表中某几行的共享锁。
- 意向排它锁(IX Lock)：事务想要获得一张表中某几行的排他锁。


> 意向锁是表级锁，意向锁之间不会发生冲突，并且不会阻塞除全表扫以外的任何请求。

||IS|IX|S|X|
|--|--|--|--|--|
|IS|兼容|兼容|兼容|不兼容|
|IX|兼容|兼容|不兼容|不兼容|
|S|兼容|不兼容|兼容|不兼容|
|X|不兼容|不兼容|不兼容|不兼容|

> 注：以上的排它共享指的是表锁，意向锁不会与行级锁互斥。

###### 意向锁的作用

当一个事务要求加表锁时，需要扫描全表去发现有无被锁定的行，但是有了意向锁，可以省略很多扫描过程，直接发现互斥关系。

#### 1.2 快照读和当前读

##### 快照读
快照读又叫一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制的方式来读取当前执行时间数据库中行的数据。并不是所有事务隔离级别下都会采用快照读，仅在事务隔离级别为RR和RC时起作用。

> 快照读在RR和RC下表现不同，RR事务隔离级别下，快照读总是读取事务开始时的数据版本。而在RC级别下，快照读总是会读取被锁定行的最新一份快照数据。

> 快照读是不需要上锁的，因此并发性能很好。

> 快照读使用undo log实现

##### 当前读
当前读又被称为一致性锁定读(consistent locking read)，顾名思义，是一种加锁读取的模式。适用于以下两个语句。

```sql
select …… for update
select …… lock in share mode
```
`select …… for update`会对行记录加上X锁，其他事务不能对已锁定的行记录加上任何锁。
`select …… lock in share mode`会对行记录加上S锁，其他事务可以对锁定航加S锁，但加X锁会被阻塞。

#### 1.3 行锁的3种表现形式

InnoDB的行锁有3中算法，分别是：
- Record Lock：单行记录上的锁。
- Gap Lock：间隙锁，锁定一个范围，不包括记录本身。
- Next-Key Lock：邻键锁，可以视为行锁+间隙锁，锁定记录本身并锁定一个范围，范围为左开右闭。

Next-Key Lock可以看做是加锁的基本单位，查找中访问到的元素都会加上前开后闭的Next-Key Lock，但又以下两种情况下会进行优化。

- 当在索引上查询条件为等值时，给`唯一索引`加锁时next-key lock会退化为行锁。
- 当在索引上查询条件为等值时，向右遍历时遇到最后一个值不满足等值条件时，next-key lock退化为gap lock。

##### 解决幻读问题

> 幻读问题是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL可能返回之前不存在的行。

###### 幻读演示
表t由1、2、5三行记录组成，会话A在一次事务查询过程中，会话B插入一条数据a=5并提交，导致会话A两次查询的结果不一致，违反了事务的隔离性，及当前事务可以看到其他事务的结果。

||session A |session B |
|--|--|--|
|1 |set session tx_isolation="READ-COMMITED"||
|2 |begin;||
|3 |select * from t where a>2 for update;<br>\*\*\*\*\*\*\*\*\*\*\*1. row\*\*\*\*\*\*\*\*\*\*<br>a:5||
|4 ||begin;|
|5 ||insert into t select 4;|
|6 ||commit;|
|7 |select * from t where a>2 for update;<br>\*\*\*\*\*\*\*\*\*\*\*1. row\*\*\*\*\*\*\*\*\*\*<br>a:4<br>\*\*\*\*\*\*\*\*\*\*\*2. row\*\*\*\*\*\*\*\*\*\*<br>a:5||

在RR的事务隔离级别下，InnoDB引入了Gap Lock和Next-Key Lock来解决幻读问题。对于上述的sql语句`select * from t where a>2 for update;`，锁住的不是5这个单个值，而是对(2,+∞)这个范围加了X锁，因此任何对于这个范围的插入都是不被允许的，从而避免幻读问题。因此要展示幻读问题，需要将事务隔离级别设为RC。

